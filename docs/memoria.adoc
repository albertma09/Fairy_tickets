= Fairy Tickets
Albert Mateos - Aitor Lopera - Diego Amador 
:icons:
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:warning-title: ATENCIÓN
:important-title: IMPORTANTE

==  Descripción de los miembros del equipo.
* Albert Mateos
* Aitor Lopera
* Diego Amador   

== Objetivos de la aplicación.
Esta aplicación tiene como objetivo la creación de una plataforma en la que publicar eventos y poner a la venta entradas para los mismos.

== Necesidades.
Las necesidades a las que esta aplicación trata de dar respuesta son las siguientes:

1. Publicación de eventos. Permitirá publicar eventos en la red para darlos a conocer al gran público.

2. CRUD de eventos. Ofrecerá un sistema de gestión para que los promotores usuarios de la app puedan llevar a cabo su trabajo de manera más eficiente e intuitiva. Así, la plataforma permitirá una gestión CRUD de los eventos.

3. Plataforma de pagos. Llevar a cabo toda la gestión de la compraventa de entradas. La aplicación se encargará de ofrecer una forma de pago segura mediante el consumo de una API (pasarela de pagos) externa.

4. Identificación de entradas y seguimiento del consumidor. La aplicación se encargará de la identificación de las entradas y el envío y recordatorio de las mismas a los clientes antes del evento.

5. Monitorización de la satisfacción del consumidor. Permitirá un sistema de _feedback_ para que los usuarios que hayan comprado una entrada puedan dar su opinión sobre el evento, y así el promotor tenga una forma directa de conocer el grado de satisfacción de sus clientes.


== Publico objetivo.
Esta aplicación está diseñada considerando dos _targets_ diferentes. 

Por un lado, tenemos a los promotores que necesitan publicar sus eventos y llevarlos a la mayor cantidad de gente posible. Este tipo de usuario será el que tenga acceso a las secciones restringidas de la aplicación que llevan a cabo todo el proceso CRUD de los eventos.
Se trata de un público corporativo y profesional, que lo que necesita es realizar su trabajo de la forma más cómoda y eficiente, resultados al menor plazo posible y retroalimentación rápida y clara.

En el otro lado, encontramos al gran público, a las personas que buscando por la red encontrarán eventos publicados en esta aplicacióna y comprarán sus entradas. Este grupo de personas, consideramos que lo compone un rango muy amplio y diverso, ya que, además, el rango de edades o los sesgos de filtraje variarán mucho dependiendo del tipo de evento que se publique. Entendiendo esto, pensamos que se tratará de personas con un mínimo poder adquisitivo que suelan tener acceso a las redes y las utilitcen a menudo. Esto engloba a personas de entre 14 y 60 años.  

==  Diseño de base de datos.
Para ver el diseño MER de la base de datos puede dirigirse al siguiente enlace:
https://drive.google.com/file/d/1jDNZInTPw_NM7lHp22TpuoQtsD87uHpR/view?usp=sharing[Esquema MER]


== Sketching y Mockups de interfícies de usuario.
.Consejo:
[TIP]
====
Para ver los detalles de los Sketching y Mockups, puede dirigirse al siguiente enlace https://www.figma.com/file/4AYrxGKE9Jr0IWjy3QuiVL/gr01-Layouts?type=design&mode=design&t=RbeKfi6LfndwQ6Wj-0[Sketching y Mockups]
====    
== Guia de estilos.
.Consejo:
[TIP]
====
En el siguiente enlace, puede encontrar toda la información a detalle de la guia de estilos de la aplicación https://www.figma.com/file/cOq2a3i65rwIY4i7gC5tbq/gr01-Gu%C3%ADa-de-estilos?type=design&node-id=0-1&mode=design&t=RbeKfi6LfndwQ6Wj-0[Guia de estilos]
====
== Manual de instalación/Distribución de la Aplicación. 
En esta sección se explicará brevemente los pasos a seguir para realizar el despliegue de la aplicación y extensiones necesarias para su funcionamiento. En primer lugar explicaremos como hacer el despliegue en local, y después en servidor, en este caso usaremos una máquina virtual ubuntu en un servidor de Isard.

CAUTION: Atención, ambos manuales explican el despliegue en una máquina con un sistema que utilice el shell _bash_. Para el despliegue en una máquina con Windows los pasos a seguir son los mismos pero la manera de instalar los diferentes _softwares_ que necesitaremos es disinta.

=== Despliegue en local

Para realizar el despliegue del proyecto en un entorno local no necesitamos ningun servidor puesto que usaremos el que lleva "built-in" artisan para servir nuestro sitio web. 

Suponiendo que la máquina en la que hagamos la instalación tiene lo básico instalado, los pasos a seguir son los siguientes:

==== Preparación del entorno

Primero de todo nos aseguraremos que cualquier dependencia que vayamos a instalar este al día.

[source,sh]
----
sudo apt update
----

Una vez hecho esto, procederemos a instalar todo el software que necesitaremos en nuestro entorno para servir el proyecto.

[source,sh]
----
sudo apt install php php-cli php-mbstring php-xml php-zip php-gd
----

[NOTE]
====
Explicación de cada una de las dependencias instaladas:

  - `php`: Instala PHP.
    - `php-cli`: Instala la interfaz de línea de comandos de PHP, necesaria para ejecutar comandos de PHP en la terminal.
    - `php-mbstring`: Instala la extensión de manejo de cadenas multibyte para PHP, necesaria para manipular texto multibyte.
    - `php-gd`: Instala la extensión GD para PHP, necesaria para manipular imágenes.
    - `unzip`: Instala la herramienta de descompresión de archivos zip. Muchas de las dependencias de Laravel vienen comprimidas así que necesitaremos un software descompresor si no lo tenemos ya.
====

Por último, hemos de instalar composer, una herramienta de gestión de dependencias de PHP, y por extensión de Laravel.

[source,sh]
----
sudo apt install composer
----


==== Clonar el Repositorio GIT

El siguiente paso es descargar todo el proyecto desde el repositorio de GIT. Para hacer esto, basta con ir al directorio de la máquina en el que se quiera instalar el proyecto y ejecutar el siguiente comando.

[source,sh]
----
git clone https://git.copernic.cat/alopera/gr01-mateos-lopera-amador.git .
----

TIP: El punto del final del comando significa en la ruta actual. Es decir en el directorio en el que nos encontremos en el momento de ejecutarlo. Si se quiere se puede cambiar por una ruta física o por una relativa. 

==== Copiar y configurar el archivo .env del proyecto

El siguiente paso consiste en localizar el archivo .env de la aplicación web, para ello nos hemos de ubicar en la carpeta raíz del repositorio, es decir allá donde lo hayamos clonado.

[NOTE]
====
El archivo `.env` en Laravel es un archivo de configuración que contiene variables de entorno para ajustar la configuración del proyecto. Debes configurar debidamente este archivo para que tu aplicación funcione correctamente.
====

[source,sh]
----
cd /ruta/a/tu/proyecto
----

Desde este punto hemos de entrar en la siguiente ruta: `fairy_tickets/`, que sería la carpeta raíz del proyecto Laravel y allá localizar el archivo `.env.example` y copiarlo en el mismo lugar pero con el nombre .env, de esta manera crearemos el archivo de variables de entorno de nuestra aplicación a partir de una plantilla preconfigurada guardada en el repositorio GIT.

[source,sh]
----
cd fairy_tickets
cp .env.example .env
----

Una vez hecho esto hemos de abrir el nuevo archivo `.env` con el editor de texto en línea de comandos nano.

[source,sh]
----
sudo nano .env
----

Una vez abierto el archivo buscamos hasta encontrar estas líneas:

[source]
----
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=
----

Y las cambiamos a:

[source]
----
DB_CONNECTION=pgsql
DB_HOST=127.0.0.1
DB_PORT=5432
DB_DATABASE=fairy_tickets
DB_USERNAME=postgres
DB_PASSWORD=root
----

Guardamos los cambios y cerramos nano:

1. Presiona `Ctrl + O` para escribir los cambios en el archivo.

2. Presiona `Enter` para confirmar el nombre del archivo (si se te solicita).

3. Presiona `Ctrl + X` para salir de `nano`.

Con esto habremos configurado lo necesario para que al levantar el contenedor de docker donde está nuestra base de datos, la aplicación conecte con ésta.

==== Instalación de dependencias del proyecto Laravel

Una vez configurado el archivo `.env`, el siguiente paso es instalar todas las dependencias necesarias para el proyecto mediante el gestor Composer.

Ubicándonos de nuevo en la carpeta fairy_tickets/, la carpeta raíz del proyecto Laravel, en la que deberíamos de encontrarnos, si se ha seguido la guía hasta este punto, lanzamos el siguiente comando:

[source,sh]
----
composer install
----

Este comando instalará todas las dependencias especificadas en el archivo `composer.json`, que son las que necesita nuestro proyecto.

Llegados aquí, en cuanto a la parte web del proyecto sólo nos quedaría generar una `APP_KEY` de Laravel para poder funcionar (a falta de base de datos y la API encargada de las imágenes). Para esto, seguimos en la carpeta raíz del proyecto Laravel `fairy_tickets/` y lanzamos el siguiente comando:

[source,sh]
----
sudo php artisan key:generate
----

==== Configuración del docker y la base de datos

En el siguiente paso, explicaremos cómo crear la imágen de docker necesaria, donde montaremos nuestra base de datos PostgreSql y posteriormente levantar el contenedor docker para que nuestra aplicación se pueda conectar a la base de datos. 

La base de datos será creada desde un script, en el momento de crear el contenedor y lanzarlo por primera vez, para poder modificar el _locale_ y la colación de la misma. 

Así, Lo primero que hemos de hacer es localizar la carpeta docker_config en el proyecto. Desde la raíz del repositorio GIT, la ruta es `~/docker-config/`. Dentro encontraremos tres ficheros: `compose.yml`, `dockerfile` y `initdb-script.sql`. 

Nos colocamos en línea de comandos en esa carpeta y montamos la imagen del dockerfile con el comando de docker: build:

[source,docker]
----
cd docker-config
docker compose build
----

Una vez creada la imagen tendremos que lanzar el comando up para lanzar los contenedores indicados en el archivo `compose.yml`:

[source,docker]
----
docker compose up -d
----

De esta manera, ya tendremos el contenedor docker de nuestra base de datos postgres en funcionamiento.

CAUTION: Atención, el archivo `compose.yml` está configurado para levantar el contenedor de Postgres y conectarlo al puerto 5432 del host, si este ya está en uso se tendra que cambiar el numero de la izquierda de la siguiente linea:

[source,yml]
----
ports:
      - 5432:5432
----

Para terminar este paso, hemos de rellenar la base de datos con algunos datos iniciales y generar las tablas que necesitará nuestra aplicación. Para ello nos colocamos, de nuevo, en la carpeta raíz del proyecto Laravel: `~/fairy_tickets` y lanzamos el comando:

[source,sh]
----
sudo php artisan db:seed
----

==== Configuración de la API

El siguiente y último paso para desplegar la aplicación en local es la configuración de la API que procesa y guarda las imágenes de la aplicación.

La API se encuentra en la carpeta `~/api` de la raíz del repositorio GIT y está todo preparado para lanzarla en un contenedor docker y que la página web se conecte a la API ahí.

Este proceso es muy parecido a lo que hemos hecho con el proyecto Laravel de la aplicación principal. Salvo que los directorios son distintos.

1. **Configuración `.env`:** Copiar el archivo .`example.env` a `.env` en la siguiente ruta desde la raíz del repositorio GIT: `~/api/ImgAda`. En este caso no hay que cambiar ninguna línea, ya está todo preparado.

2. **Composer install:** En la misma ruta que el paso anterior lanzar el comando `composer install`.

3. **Creación de clave `APP_KEY`**: En la misma ruta que los dos pasos anteriores lanzar el comando `sudo php artisan key:generate`.

4. **Creación de imágen Docker y lanzamiento de contenedores**: nos ubicamos en la carpeta `~/api/api-docker` desde la raíz del repositorio GIT. Hay deberían de haber dos archivos, el archivo `dockerfile` con lo necesario para crear la imagen que se usará en el contenedor y las instrucciones para el levantamiento en el archivo `docker-compose.yml`. Una vez ubicados aquí lanzamos los comandos `docker compose build` y cuando termine de generar la imagen `docker compose up -d`.

CAUTION: En este caso, la API se conecta al puerto 8088 del host, si estuviera ocupado hay que cambiarlo de la misma manera que en el paso levantamiento del docker de la base de datos.

Ahora deberíamos tanto la base de datos como la API corriendo en sendos contenedores docker y en principio debería de estar todo listo para el uso de la aplicación

==== Puesta en marcha de la web

Para comprobar que todo funciona bien y empezar a usar la web en local puedes iniciar el servidor de desarrollo de Laravel utilizando el comando `php artisan serve`:

[source,sh]
----
php artisan serve
----

Esto iniciará un servidor de desarrollo en `http://localhost:8000`, donde podrás acceder a la aplicación.

=== Isard
Instala Apache2 y PHP en tu servidor Debian ejecutando los siguientes comandos:

[source,sh]
----
sudo apt update
sudo apt install apache2 php php-cli php-mbstring unzip
----

==== Configuración de Apache2

Edita el archivo de configuración de Apache2 para permitir el uso de archivos `.htaccess` y habilitar el módulo `rewrite`:

[source,sh]
----
sudo nano /etc/apache2/sites-available/000-default.conf
----

Agrega las siguientes líneas dentro de la sección `<VirtualHost>`:

[source,apache]
----
<Directory /var/www/html>
    AllowOverride All
</Directory>
----

Guarda los cambios y reinicia Apache:

[source,sh]
----
sudo service apache2 restart
----

===== Despliegue del Proyecto desde Git

Para comenzar con el despliegue accederemos a la url de nuestro proyecto: https://git.copernic.cat/alopera/gr01-mateos-lopera-amador

Buscaremos un boton que ponga code y copiaremos la url que se indica que en este caso es la siguiente: https://git.copernic.cat/alopera/gr01-mateos-lopera-amador.git

Clonamos el proyecto dentro del directorio `/var/www/html` de la siguiente manera:

[source,sh]
----
sudo git clone https://git.copernic.cat/alopera/gr01-mateos-lopera-amador.git /var/www/html
----

Accede al directorio del proyecto y ejecuta la instalación de dependencias de Laravel, para hacerlo tiene que ser dentro de la carpeta del proyecto laravel, en este caso es la carpeta fairy_tickets:

[source,sh]
----
cd /var/www/html/gr01-mateos-lopera-amador/fairy_tickets
sudo composer install
----

===== Configuración del archivo .env en Laravel


El archivo `.env` en Laravel es un archivo de configuración que contiene variables de entorno para ajustar la configuración del proyecto, incluyendo la conexión a la base de datos, la configuración de correo electrónico, entre otros. En este documento, explicaremos cómo configurar correctamente el archivo `.env` para que funcione correctamente tu proyecto Laravel.

====== Pasos para configurar el archivo .env:

1. **Copiar el archivo .env.example**: Antes de comenzar, asegúrate de copiar el archivo `.env.example` que se proporciona en el proyecto Laravel y renombrarlo como `.env`.

2. **Configuración de la conexión a la base de datos**:

    ```
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=nombre_base_de_datos
    DB_USERNAME=nombre_usuario
    DB_PASSWORD=contraseña
    ```

    Reemplaza `nombre_base_de_datos` con el nombre de tu base de datos, `nombre_usuario` con el nombre de usuario de la base de datos, y `contraseña` con la contraseña correspondiente.

3. **Configuración de otros ajustes**: Además de la conexión a la base de datos, puedes configurar otras variables de entorno en el archivo `.env` según sea necesario. Algunas de las variables comunes incluyen:

    ```
    APP_NAME=Nombre_de_la_aplicación
    APP_ENV=local
    APP_KEY=Clave_secreta_generada_por_Artisan
    APP_DEBUG=true
    APP_URL=http://localhost
    ```

    ```
    MAIL_MAILER=smtp
    MAIL_HOST=smtp.mailtrap.io
    MAIL_PORT=2525
    MAIL_USERNAME=your_username
    MAIL_PASSWORD=your_password
    MAIL_ENCRYPTION=tls
    MAIL_FROM_ADDRESS=your_email@example.com
    MAIL_FROM_NAME="${APP_NAME}"
    ```

    Configuración de la app principal
    ```
    #numero de eventos a mostrar en el home por categoría
    EVENTSBYCATEGORY = 4 

    #URL de la conexión a la pasarela de pagos
    URL_CONNECTION = https://sis-t.redsys.es:25443/sis/realizarPago 

    #URL de los errores de la pasarela
    URL_DESCRIPTION_ERROR = https://pagosonline.redsys.es/codigosRespuesta.html 

    # Líneas de configuración de la pasarela de pagos
    DS_MERCHANT_CURRENCY = 978
    DS_MERCHANT_MERCHANTCODE = 999008881
    DS_MERCHANT_TERMINAL = 001
    DS_MERCHANT_TRANSACTIONTYPE = 0
    Ds_SignatureVersion = HMAC_SHA256_V1
    claveSHA256 = sq7HjrUOBfKmC576ILgskD5srU870gJ7
    ACTIVEREDSYS = true

    # Líneas de configuración de la conexión a la API

    # Tamaños deseados para las diferentes versiones de las imágenes, en píxeles (puede variar la cantidad de tamaños)
    IMAGE_SIZES = [300,700,1600]

    # URL de la conexión a la API
    IMAGE_API_URL= "http://127.0.0.1:8088/api/v1/images"

    # Contraseña para los endpoints protegidos de la API
    IMAGE_API_KEY= "CxSJj7WKdWYy90hX4vJjaS6JK2"
    ```

    Asegúrate de ajustar estos valores según las necesidades específicas de tu proyecto.

Genera la clave de aplicación de Laravel:

[source,sh]
----
sudo php artisan key:generate
----

Establece los permisos adecuados para los directorios de almacenamiento y de caché:

[source,sh]
----
sudo chmod -R 775 storage bootstrap/cache
sudo chown -R www-data:www-data storage bootstrap/cache
----

===== Configuraciones Adicionales

Configura el host virtual de Apache2 para apuntar al directorio del proyecto Laravel. Edita el archivo `/etc/apache2/sites-available/000-default.conf`:

[source,apache]
----
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html/gr01-mateos-lopera-amador/public

    <Directory /var/www/html/gr01-mateos-lopera-amador/public>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>
----

Guarda los cambios y reinicia Apache:

[source,sh]

----
sudo service apache2 restart
----    

= Documentación de la API de almacenamiento de imágenes

Esta API permite el almacenamiento de imágenes para su optimización en el uso web. Recibe una imagen y una serie de tamaños en formato _array_ numérico, reescala la imagen a cada uno de esos tamaños y devuelve un _array_ con las _URLs_.

La aplicación recibe una imagen, verifica que se pueda tratar como imagen y la procesa, reescalándola a los tamaños designados. Por cada tamaño guarda un archivo de imagen diferente. Una vez guardados estos archivos, como respuesta a la petición POST, devolverá una url por cada imagen creada. Esta url contendrá el nombre de archivo encriptado y se podrá usar para acceder a la versión de la imagen guardada que se necesite.

En la actual versión (v1), solo trabaja con tres _endpoints_:


- GET api/v1/images/{filename}: Este endpoint se utiliza para recuperar una imagen específica. Toma como parámetro el nombre de archivo encriptado y devuelve la imagen correspondiente si existe.

- POST api/v1/images: Este endpoint se utiliza para subir y guardar una imagen. Recibe por parámetros, en el cuerpo de la request, el archivo de la imagen que se quiere procesar y un array numérico con cada uno de los tamaños que se necesitan. Una vez verificados la imagen y el array numérico, la procesa y devuelve un array de tantas URLs como tamaños distintos se hayan requerido. Esta respuesta se enviará en formato JSON y en orden ascendente, es decir de más pequeño a más grande.

- DELETE api/v1/images: Este endpoint se utiliza para eliminar una imagen previamente guardada. Recibe por parámetros, en el cuerpo de la request, un array con las URLs de las imágenes que se quieren eliminar. Una vez verificadas las URLs se procede a la eliminación de las imágenes correspondientes. Si todo va bien se devuelve un json con el array del nombre de los ficheros eliminados. 


== GET: Recuperar una imagen

Recupera la imagen indicada a través del parámetro.

[cols="2,8",options="header"]
|===
| Parámetros de la petición | Descripción
| filename | Código de la imagen a recuperar.
|===


.Ejemplo de solicitud:

[source]
----
GET http/localhost:8088/api/v1/images/{filename} HTTP/1.1
Host: example.com
----

[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | OK - Devuelve un archivo de imagen.
| 400 | El parámetro es erróneo.
| 404 | No encontrado - Archivo no encontrado.
| 500 | Error de servidor - Ha ocurrido un error inesperado.
|===

== POST: Subir una imagen

Sube una imagen y devuelve un array de tres URLs en formato JSON.

[options="header"]
|===
| Cuerpo de la petición
| Content-Type: multipart/form-data
|===
[cols="2,3,6",options="header"]
|===
| Nombre del parámetro | Tipo de valor | Descripción
| image | Archivo de imágen (jpg, jpeg...) | El archivo de imagen que se va a cargar.
| sizes | Array numérico ([250,600,1600]) | El array de tamaños a los que se requiere reescalar la imagen.
|===

.Ejemplo de solicitud:

[source]
----
POST http/localhost:8088/api/v1/images HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="image"; filename="example.jpg"
Content-Type: image/jpeg

<contenido binario de la imagen>
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="sizes"
[250, 700, 1800]
----WebKitFormBoundary7MA4YWxkTrZu0gW--
----

[[post-example-response-200]]
.Ejemplo de respuesta exitosa (200)

[source,json]
----
[
"http://127.0.0.1:8088/api/v1/images/url1",
"http://127.0.0.1:8088/api/v1/images/url2",
"http://127.0.0.1:8088/api/v1/images/url3"
]
----
Este ejemplo devuelve tres URLs correspondientes a los diferentes tamaños de la imagen subida en orden ascendente.

Estas URLs pueden utilizarse para acceder a las imágenes optimizadas después de la carga.

[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | OK - Devuelve un array con tres urls.
| 400 | El archivo subido no tiene un formato de imagen válido.
| 413 | El tamaño del archivo de imagen excede el límite.
| 500 | Error de servidor - Error inesperado: No se ha podido procesar la imagen.
|===

== DELETE: Eliminar imágenes

Elimina imágenes basadas en las URLs proporcionadas mediante un array y devuelve otro array con el nombre de los ficheros eliminados.

[cols="2,8",options="header"]
|===
| Parámetros de la petición | Descripción
| urls | Array de URLs de las imágenes a eliminar.
|===

.Ejemplo de solicitud:

[source]
----
DELETE http://localhost:8088/api/v1/images HTTP/1.1
Content-Type: application/json
Host: example.com

{
    "urls": [
        "http://example.com/url1",
        "http://example.com/url2"
   ]
}
----

[[delete-example-response-200]]
.Ejemplo de respuesta exitosa (200)

[source,json]
----
{
   "archivos_eliminados": [
      "url1",
      "url2",
   ]
}
----
Este ejemplo devuelve el código del final de las dos URLs correspondientes a los nombres de las dos imágenes que se ha pedido que se eliminaran.


[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | Imágenes eliminadas correctamente.
| 400 | Petición incorrecta - No se proporcionaron URLs válidas o el tamaño del archivo excede el límite.
| 404 | Archivo no encontrado - Archivo no encontrado para alguna de las URLs proporcionadas.
| 500 | Error de servidor - No se pudo eliminar alguna de las imágenes.
|===

== Desplegar API en servidor isard

Para comenzar tendremos que tener el proyecto desplegado dentro del servidor isard, en nuestro caso la API ya esta dentro del proyecto tickets, tendremos que acceder a la siguiente ruta:

[source,sh]
----
cd /var/www/html/gr01-mateos-lopera-amador/api/ImgAda
----

Una vez dentro de la ruta copiaremos el fichero .env.example y generaremos la key:

[source,sh]
----
sudo cp .env.example .env
sudo php artisan key:generate
----

una vez la llave generada accederemos a la ruta `/var/www/html/gr01-mateos-lopera-amador/api/api-docker` que es donde tenemos los archivos de confuguración del docker y ejecutaremos los siguientes comandos para generar el contenedor docker:

[source,sh]
----
sudo docker compose build
sudo docker compose up -d
----



= Documentación de la API de verificación de tickets

Esta Api te permite verificar si el ticket de una sesion es valido o no.
Primero se loguea mediante el codigo de la sesión y una vez logueado mediante el lector qr se verifica el id del ticket y comprueba si existe y si es de la sesión que pertoca, una vez este eso comprobado mira si ese ticket ya ha sido verificado o no, si no esta verificado lo da por valido y lo verifica, y si ya lo esta manda un error.

En la versión actual (v1), trabaja con 3 endpoints:

GET /verify-ticket/{ticket_id}: Este endpoint se utiliza para comprobar si un ticket es valido dentro de la sessión iniciada. Toma como parámetro el id del ticket y devuelve si es valido o no y porque.

POST /login: Este endpoint utiliza un codigo de sesion con el que se realizara el inicio de sesion. Si es valido se creara un token para identificar la sesión.

POST /logout: Este endpoint utiliza un token almacenado en una cookie al iniciar sesión. Al ejecutarse este elimina la cookie y el token de la base de datos.

== login
Introduces el codigo y te devuelve un token en formato JSON.

[options="header"]
|===
| Cuerpo de la petición
| Content-Type: application/form-data
|===
[cols="2,8",options="header"]
|===
| Nombre del parámetro | Descripción
| code | codigo de la sesion con la que haremos login.
|===

.Ejemplo de solicitud:

[source]
----
POST /login HTTP/1.1
Host: example.com
Content-Type: text/plain

code=your_code_here
----

.Ejemplo de respuesta exitosa (200)

[source,json]
----
[source,json]
[
"token": "bepNyKZHiiwXl1X",
"session_id": 1
]
----
Este ejemplo devuelve un token y el id de la sesion a la que se esta accediendo.

Estos datos se utilizaran para comprobar los tickets que se esten verificando si pertenecen a la sesion y si son validos

[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | OK - Devuelve un token y el id de la sesión.
| 401 | Error de autenticación - El codigo no es valido.
| 500 | Error de servidor - Ha ocurrido un error inesperado.
|===

== Logout

Al darle a logout elimina el token de la base de datos y la cookie donde estaba almacenado.

[options="header"]
|===
| Cuerpo de la petición
| Content-Type: application/form-data
|===
[cols="2,8",options="header"]
|===
| Nombre del parámetro | Descripción
| token | token creado del inicio de sessión.
|===

.Ejemplo de solicitud:

[source]
----
POST logout HTTP/1.1
Host: example.com
Content-Type: application/form-data

token=your_token_here
----

[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | OK - Devuelve un mensaje indicando que el logout fue exitoso.
| 500 | Error de servidor - Ha ocurrido un error inesperado.
|===

== Verificar ticket
Mediante un codigo qr se identifica el id del ticket y se verifica si es valido.

[options="header"]
|===
| Cuerpo de la petición
| Content-Type: application/form-data
|===
[cols="2,8",options="header"]
|===
| Nombre del parámetro | Descripción
| id | id del ticket que se esta comprobando.
|===

.Ejemplo de solicitud:

[source]
----
GET /verify-ticket/7 HTTP/1.1
Host: example.com
----


[cols="2,8",options="header"]
|===
| Código de estado | Descripción
| 200 | OK - Devuelve un mensaje indicando que el ticket es valido, y si es nominal también te añade los datos del cliente.
| 400 | El parámetro es erróneo.
| 401 | Error de autenticación - El codigo no es valido.
| 404 | No encontrado - Ticket no encontrado.
| 500 | Error de servidor - Ha ocurrido un error inesperado.
|===




== Configuración del docker y la base de datos

En este apartado se explica cómo crear la imágen de docker necesaria, donde montaremos nuestra base de datos PostgreSql. 

La base de datos será creada desde un script, en el momento de crear el contenedor y lanzarlo por primera vez, para poder modificar el _locale_ y la colación de la misma. 


Así, Lo primero que hemos de hacer es localizar la carpeta docker_config en el proyecto. Dentro encontraremos tres ficheros: `compose.yml`, `dockerfile` y `initdb-script.sql`. 

Nos colocamos en línea de comandos en esa carpeta y montamos la imagen del dockerfile con el comando de docker: build:

[source,docker]
----
docker compose build
----

Una vez creada la imagen tendremos que lanzar el comando up para construir los contenedores indicados en el archivo `compose.yml`:

[source,docker]
----
docker compose up -d
----

De esta manera, ya tendremos el contenedor docker de nuestra base de datos postgres en funcionamiento.

== Sprints
=== Sprint 1
==== Trabajo realizado
Durante esta semana, nos enfocamos en 5 nuevas tareas del desarrollo de la aplicación:

===== R01: Definir Guía de Estilos de la Aplicación 

* Definir la paleta de colores para los elementos de la aplicación.
** Especificar los colores utilizados y justificar su elección.

* Indicar la tipografía para diferentes textos de la aplicación.
** Niveles de títulos, cuerpo del texto, citas, palabras resaltadas y otros.
** Especificar tamaños de fuente según la ubicación del texto.

* Especificar la iconografía utilizada en la aplicación.
** Representar colores y tamaños posibles para las iconas.
** Si la icona forma parte de un botón, este debe ser descrito.

* Describir los botones de la aplicación.
** Mencionar tamaños, márgenes, espaciados, fuentes, colores y comportamientos.
** Detallar comportamientos como hover, seleccionado, importante, etc.

* Detallar estilos de enlaces y elementos de formulario.
** Incluir cómo se ven cuando son visibles, editables o no interactivos.

* Describir gráficos y visualizaciones de componentes.
** Mostrar ejemplos de tarjetas u otros elementos.

===== R02: Plantejar l'Estructura de la Base de Dades 

* Considerar al menos las entidades mencionadas.
** Agregar el diagrama relacional y de clases a la memoria.
** Mantener actualizado este diagrama a lo largo del desarrollo.

===== R03: Entorn de Desplegament a Isard 

* Desplegar semanalmente en Isard con consideraciones específicas.
** Respetar rangos de direcciones IP asignadas.
** Mostrar un diagrama de red actualizado en el README.

* Instalar solo la aplicación web principal en la máquina Isard.
** Dockerizar otros servicios como SGBD y servidor DNS.

===== R04: Layout Principal

* Diseñar nombre y logo para la aplicación.
* Crear favicon.ico.
* Todas las páginas tendrán un header y un footer.

===== R05: Pàgina Home
* Diseñar la página de inicio como punto de entrada.
* Mostrar lista provisional de eventos con detalles.
* Incluir un buscador y filtros por categoría.
* Paginar y configurar la cantidad de registros por página.
* Implementar pruebas funcionales y migraciones de base de datos.

===== Notas Adicionales

* Utilizar fuentes de inspiración como Material Design y Dribbble.
* Mantener actualizada la documentación en la memoria.
* Agregar enlaces a Figma para ejemplos visuales.



==== Tareas

.Tareas Realizadas
[options="header"]
|====================
| Tarea 3+^| Descripción
| **R01: Definir Guía de Estilos de la Aplicación** 3+|
"El primer paso que hemos dado esta semana ha sido centrarnos en el diseño del sitio web y decidir qué colores, fuentes, iconos, etc... eran más adecuados para la temática de nuestro sitio.

1. Paleta de colores.
Entendemos que una aplicación así está orientada a un público sobre todo joven o de mediana edad y que necesitamos colores que llamen a la acción, así que nos hemos decidido por usar un tono rojo/rosado como color de marca sobre un fondo oscuro (gris casi negro), así como un color blanco para que los elementos tengan contraste sobre el fondo.

2. Tipografía.
Hemos buscado tres fuentes que nos parezcan adecuadas con la temática, sean agradables a la vista, se lean bien en pantallas pequeñas y combinen bien entre sí. Una, sin serifa, será para la mayoría de textos y botones. La segunda, para los títulos y textos destacados. Y la tercera, con serifa y más estilizada, para citas destacadas y títulos artísticos.

3. Iconografía.
En cuanto a iconos hemos decidido optar por usar los de la librería font-awesome 5, que nos parecen quedan mejor con nuestro estilo y es gratis.

4. Espacios y formas.
Hemos decidido usar medidas a partir del tamaño de la fuente (rem), ya que al cambiar de pantalla, cambiamos de tamaño de fuente y en teoría todo debería de quedar proporcionado.
Buscamos cual era el espacio estándar entre el contenido y los bordes en pantallas móviles y a partir de ahí lo escalamos según la pantalla. 
También decidimos darle a la mayoría elementos de nuestro sitio web, botones, cards, contenedores... un aspecto rectangular con los bordes recortados en las esquinas.

5. Botones.
Los botones hemos decidido que usarían la misma fuente que el texto normal del sitio web. Tendrán un borde del color de la 'marca' de la web y un fondo transparente que se rellenará al hacer hover con el mismo color que el borde.
" 

| **R02: Plantear la Estructura de la Base de Datos** 3+|
"" 

| **R03: Entorno de Despliegue en Isard** 3+|
"Para implementar el despliegue en el entorno Isard, realizamos los siguientes pasos:

Instalación de Apache2 y PHP:

Actualiza la lista de paquetes e instala Apache2 y PHP.
Configuración de Apache2:

Permite el uso de archivos .htaccess y habilita el módulo rewrite.
Despliegue del Proyecto desde Git:

Clona el proyecto Laravel desde Git en /var/www/html.
Instala las dependencias de Laravel y configura el archivo .env.
Configuraciones Adicionales:

Configura el host virtual de Apache2 para apuntar al directorio del proyecto Laravel." 

| **R04: Diseño Principal** 3+|
"En el diseño, hecho en FIGMA, hemos querido optar por un _layout_ tradicional, con un navegador horizontal estático en la parte de arriba, en el que habrán: el logo, un buscador, los links del navegador y un botón para hacer login o logout. El contenido ocupando el centro de la pantalla y un footer al final del contenido.
El navegador en pantallas pequeñas pierde los links y aparece un botón tipo _toggle_ para desplegarlos. 
Pese a explicarlo de esta manera, el diseño lo hemos intentado hacer mobile first, es decir, primero diseñamos la vista móvil y después cómo se expandirían los elementos en el espacio.
" 

| **R05: Página de Inicio** 3+|
"" 
|====================


==== Valoración individual
Valoración de la semana individual

===== *Diego:*


===== *Aitor:* En este sprint me he dedicado principalmente a la guía de estilos junto a mis compañeros. En este sentido, me he dedicado a buscar las fuentes y las tipografías. También me he encargado del diseño principal de la página: el layout, el navegador y el home.


===== *Albert: Este sprint he estado sobretodo con la configuración de la maquina isard, además de esto junto con mis compañeros estuvimos decidiendo los estilos de la pagina y con esto creamos la guia de estilos* 

=== Sprint 2
==== Trabajo realizado
Durante esta semana, nos enfocamos en 7 nuevas tareas del desarrollo de la aplicación:


===== R06: Página Resultados de búsqueda

Como usuario no registrado:
- Navegar por la página.
- Mostrar resultados aplicando un filtro por categoría.
- Mostrar resultados de una búsqueda.

===== R07: Refactor Página Home

Como usuario no registrado:
- Navegar por la página.
- Mostrar un único buscador compartido con la página de resultados.
- Mostrar para cada categoría el título, un número determinado de eventos y el total desde la configuración de la aplicación.
- Acceder a la página de resultados de búsqueda por categoría.

===== R08: Página Home para Promotores

Para Promotores:
- Acceder a una área independiente con un enlace en la página principal y en el footer.
- El enlace dirige a la página de login si no están autenticados, o a la página Home Promotor si lo están.

===== R09: Página Login

Para Promotores y Administradores:
- Acceder al sistema mediante esta página.
- Mostrar la página Home Promotor después del login.
- Mostrar siempre el usuario logado.
- Acceder a la página de perfil de usuario (en futuros sprints).
- Habilitar la opción de cerrar sesión (Sign out).

===== R10: Cerrar Sesión

Para Promotores y Administradores:
- Eliminar variables de sesión.
- Considerar limpieza de cookies, local storage, etc.
- Redireccionar a la página Home de promotores.

===== R11: Olvidé la Contraseña

- Acceder desde la página de login.
- Enviar un email con un enlace único y caducidad de 1 hora.
- Redirigir a una página para cambiar la contraseña.
- Mostrar requisitos y dar retroalimentación.
- Configurar el tiempo de caducidad desde el archivo de configuración.

===== R12: Página Crear Evento

Para Promotores:
- Crear eventos con título, categoría, dirección, imagen principal, descripción, fecha y hora, aforo máximo, entradas y más.
- Permitir seleccionar o añadir nuevas direcciones.
- Mostrar enlace "ver mapa" después de publicar el evento.
- Configurar cierre de venta online.
- Opción para ocultar el evento.
- Opción para entradas nominales.

.Tareas Realizadas
[options="header"]
|====================
| Tarea 3+^| Descripción

| R06: Página Resultados de búsqueda 3+| ""

| R07: Refactor Página Home 3+| ""

| R08: Página Home para Promotores 3+| ""

| R09: Página Login 3+| "
Implementación del Login en Laravel:
Configuración del Modelo y Migración:

Asegúrate de tener el modelo User y su migración.
Rutas de Autenticación:

Utiliza Auth::routes(); para habilitar las rutas predefinidas de autenticación.
Protección de Rutas:

Emplea el middleware auth en los controladores para proteger las rutas que requieren autenticación.
Personalización de Vistas:

Adapta las vistas en resources/views/auth según tus necesidades específicas."

| R10: Cerrar Sesión 3+| "Implementación del Logout en Laravel:
Ruta para el Logout:

Crea una ruta que apunte al método logout en el controlador LoginController.
Enlace de Logout:

Agrega un enlace en la vista que dirija a la ruta de logout."

| R11: Olvidé la Contraseña 3+| "Implementación de la Recuperación de Contraseña con Mailtrap en Laravel:
Configuración del Servicio de Correo:

Configura .env con las credenciales de Mailtrap.
Personalización de Configuración de Correo:

Ajusta config/mail.php para utilizar la configuración de Mailtrap.
Generación del Controlador para Reset de Contraseña:

Añadir Rutas Necesarias:

En routes/web.php, agrega rutas para reset de contraseña.
Creación de Vistas:

Personaliza las vistas en resources/views/auth/passwords según tus necesidades.
Personalización del Correo de Reset de Contraseña:

Edita resources/views/auth/passwords/email.blade.php para personalizar el correo de reset.
Configuración de Notificación de Reset de Contraseña:

Asegúrate de que el modelo User utilice el trait Notifiable para recibir notificaciones." 

| R12: Página Crear Evento 3+|  **Diseño Inicial**

La página crear evento se trata de un formulario en el que el promotor podrá crear nuevos eventos. Esta vista no puede ser accesible por cualquier usuario, solo los promotores deben poder acceder.
Este requerimiento ha llevado varias semanas de trabajo.
Para ello, primero hemos hecho una actualización de la base de datos conforme a las relaciones entre eventos, direcciones, sesiones y tipos de ticket.

Consideramos que un evento, pertenece a un promotor tiene una y solo una ubicación y puede tener varias sesiones.
Una sesión pertenece a un evento y puede tener varios tipos de ticket.

Hecho esto, el siguiente paso ha sido crear los modelos, las migraciones, las factories y actualizar el seeder, para comprobar que el diseño de la base de datos era coherente.

Acto seguido nos hemos dispuesto a hacer un sketch de las vistas. Para este caso, hemos intentado hacerlo lo más sencillo posible, juntanto los inputs y sus labels correspondientes en containers y colocándolos unos encima de otros.

En cuanto hemos tenido el sketch nos hemos puesto a crear la estructura html en la vista. Añadiendo los atributos necesarios para la validación html que consideramos adecuada para cada input.

**Insertar nueva ubicación**

El siguiente paso ha sido decidir como lidiar con las direcciones. Esta fue la primera encrucijada que nos encontramos, no saber si haciamos bien en tener ubicaciones propias para cada usuario o, por el contrario, tener una base de datos de ubicaciones compartidas de las que los usuarios pudieran elegir las direcciones.

Al principio decidimos hacer lo segundo, pero una vez hecha toda la estructura de base de datos y haciendo pruebas con las factories y el seeder nos decantamos por cambiarlo, y hacer que a cada usuario le aparecieran las direcciones que ya había usado anteriormente. Esto lo hemos hecho así porque de la otra manera era muy fácil que se duplicaran datos por diferencias en mayúsculas, puntuación, acentuación, etc... Así que, puestos a tener duplicados de la información, decidimos que era mejor que cada usuario tuviera sus propias direcciones en la tabla.

Al final, después de todos los cambios, tuvimos que ver como íbamos a implementarlo en la estructura html del formulario. Nuestra decisión ha sido permitir la opción de añadir una nueva dirección en el desplegable de las direcciones. 
Al clicar en añadir una nueva dirección se abre un formulario en un dialog que permite la inserción de nuevas direcciones, por ahora decidimos no centrarnos en la validación y lo dejamos desnudo pero funcional.

Esto significa que hemos tenido que hacer el controlador para las ubicaciones llamado LocationController, y dentro el método store al cual apunte el action del formulario nuevo. Aquí si que hemos hecho las validaciones pertinentes antes de guardar los datos en la tabla.



*Primera versión del formulario*

En la primera versión funcional del formulario intentamos centrarnos en que todo funcionara añadiendo sólo una sesión y un tipo de ticket en la sesión.

Primero de todo revisamos todos los tipos de input y sus atributos y que estuvieran en consonancia con lo que se pedía de ellos en el requerimiento.

**Funcionalidades JavaScript.**
En este punto, nos dimos cuenta que eran necesarias varias funcionalidades de JS para el correcto funcionamiento y la coherencia del formulario. 

Estas son:

- Mostrar el formulario de nueva dirección al hacer click en esa opción en el desplegable.

- Mostrar input de cierre de la venta online manual al hacer click en el radio que le da esa opción al usuario.

- Que al seleccionar una ubicación se usara la capacidad máxima de esa ubicación para rellenar el atributo "max" del input de Aforo de la sesión.

**Validación e inserción**

Una vez hecho esto, y con el JS funcionando, lo siguiente era crear la función "store" del controlador de eventos. 
Esto lo hemos hecho usando el método "validate" de laravel y guardando, de momento, las imágenes en el storage de nuestro proyecto.

Una vez comprobado que los datos llegaban bien al controlador, se validaban de forma correcta y se guardaba el evento, nos disupsimos a hacer que se guardara la primera sesión de ese evento. 

En este proceso hemos tenido que crear métodos propios de inserción de datos a base de datos porque teníamos que hacer retoques a los inputs de la request antes de guardarlos. Esto es sacar los inputs que no necesitabamos para crear el evento y lo mismo para la sesión y los tickets.

**Crear primera sesión con multiples tipos de ticket.**

En este punto, y una vez comprobado que todo el proceso de validación e inserción de datos del formulario funcionaba bien, teniamos que conseguir poder insertar más de un tipo de ticket a la vez en una sesión.

Para ello lo primero fue averiguar como mandar un array de datos bajo el mismo "name" de input. Esto se consigue añadiendo una apertura y cierre de corchete justo después del nombre que se haya puesto en el atributo "name", por ejemplo: <input ... name="minput[]" ... />

Así, decidimos crear un nuevo componente que fuera el tipo de ticket, creamos un conjunto de inputs con la validación y los inputs adecuados, y teniendo cuidado que sus "id"s y los "for"s de sus labels no se repitieran, para ello le pasamos al componente un índice, en el caso que se tuviera que crear varias instancias del componente.

Siguiendo este modelo, en JS añadimos la funcionalidad de poder añadir o quitar tipos de ticket, cuidando de que siempre hubiera mínimo uno, y de que no se repitieran los atributos que debían de mantenerse únicos.

Con esa funcionalidad lista, lo único que queda es refactorizar las validaciones en el back-end, y los métodos de guardado de sesiones, para en vez de guardar un ticket relacionado con la sesión actual, se guarde un array de tickets.
"

|====================

==== Valoración individual
Valoración de la semana individual

===== *Diego:*


===== *Aitor: Esta semana, y algunas que le siguen, me he encargado de hacer todo lo relacionado con el formulario de creación de eventos. Resultó ser mucho más complejo de lo esperado. Era como tener que construir algo muy grande mediante pequeñas piezas que cuando no encajaban se tenían que ir limando hasta que se podían unir al conjunto sin hacerlo explotar.
* 


===== *Albert: Este sprint he estado con el desarrollo tanto visual como funcional de todo el sistema de autenticación de usuario* 

=== Sprint 3
==== Trabajo realizado
Durante esta semana, nos enfocamos en 4 nuevas tareas del desarrollo de la aplicación:

===== R13: Añadir múltiples sesiones a un evento

- Permite agregar nuevas fechas (sesiones) a un evento existente.
- La creación de una nueva sesión implica duplicar los datos de la sesión por defecto, como la fecha y hora, aforo máximo, tipos de entradas y precios.
- Muestra los datos duplicados en modo edición para realizar cambios si es necesario.
- Permite gestionar los tipos de entrada de manera independiente para cada sesión.
- Solo disponible para los promotores de eventos.

===== R14: Página resumen Lista de sesiones abiertas

- Muestra la lista de sesiones abiertas del promotor.
- Ordenadas por fecha, priorizando las más cercanas.
- Para cada sesión, se muestra la imagen principal, título, fecha y estado de ventas de entradas.
- Acceso a detalles de evento, administración y listados de entradas de cada sesión.
- Enlace temporal desde la página principal de promotores.

===== R15: Página Administrar eventos

- Disponible en la página principal de promotores.
- Lista de eventos con información básica y opciones para editar.

===== R16: Página mostrar evento

- Muestra el nombre, fotos, descripción e información del lugar del evento.
- Calendario para las sesiones si hay más de una.
- La selección de una sesión muestra la lista de entradas disponibles.
- Seleccionar cantidad de entradas por tipo y calcular el precio total.
- El botón "comprar" redirige a la Pantalla de confirmación de compra (Pendiente).

.Tareas Realizadas
[options="header"]
|====================
| Tarea 3+^| Descripción

| R13: Añadir múltiples sesiones a un evento 3+| ""

| R14: Página resumen Lista de sesiones abiertas 3+| ""

| R15: Página Administrar eventos 3+| ""

| R16: Página mostrar evento 3+| "Para realizar esta página primero debemos recivir todos los datos del evento, que son sus propios datos "

|====================

==== Valoración individual
Valoración de la semana individual

===== *Diego:*


===== *Aitor:* 


===== *Albert: Este sprint principalmente he estado con el desarrollo de la pagina de detalles del evento, haciendo que se puedan ver imagenes, el nombre y descripción del evento, las sesiones y la locación.

Además también estuve haciendo la pantalla de home promotor para que se pudiesen ver los eventos de cada usuario y mejorar el aspecto visual.* 

=== Sprint 4
==== Trabajo realizado
Esta semana nos hemos dedicado a corregir los siguientes puntos:

Documentación::


- Actualizamos y completamos la documentación del proyecto, asegurándonos de que esté al día y refleje con precisión los últimos cambios y configuraciones.
- Actualizamos el diagrama de la base de datos para representar de manera precisa la estructura actual.
- Verificamos y actualizamos todos los enlaces en la documentación para garantizar su funcionalidad y accesibilidad.

Pruebas::


- Mejoramos la suite de pruebas, llevándolas a cabo con una base de datos independiente de la de producción para una mayor integridad de los datos.
- Validamos exhaustivamente todos los caminos posibles en el código para garantizar su funcionalidad y estabilidad.

Despliegue::


- Solucionamos problemas de configuración en el VirtualHost de Apache y Docker, asegurando un despliegue sin problemas y eficiente.
- Optimizamos el entorno Docker eliminando comandos adicionales y archivos de configuración no utilizados.

Diseño::


- Mejoramos la experiencia del usuario utilizando grid y SASS en todo el proyecto.
- Actualizamos todas las pantallas de la aplicación en Figma, incluyendo bocetos detallados para cada una antes de su implementación.
- Organizamos el código de manera más limpia y estructurada, evitando la mezcla de lógica, vistas y scripts de JavaScript.

=== Sprint 5
==== Trabajo realizado
Durante esta semana, nos enfocamos en 9 nuevas tareas del desarrollo de la aplicación:

===== Pantalla de Confirmación de Compra (R17)

  - Mostrar un resumen de la compra con detalles del evento, fecha, hora, precios y total.
  - Solicitar información personal (nombre, DNI, teléfono) para cada asistente si las entradas son nominativas.
  - Solicitar correo electrónico del comprador.
  - Contar con un contador regresivo para completar la compra y redireccionar si se agota.
  - Botón para finalizar la compra.

===== Pasarela de Pago (R18)

  - Implementar el pago con tarjeta de crédito utilizando la plataforma Sandbox de RedSys versión REST.

===== Gestión de Errores en el Pago (R19)

===== Generación de Entradas (PDF) (R20)

  - Generar entradas en formato PDF después de un pago exitoso.
  - Incluir logo de la plataforma, detalles del evento, tipo de entrada, códigos QR y numéricos únicos.
  - Incluir nombre y DNI del propietario si la entrada es nominativa.

===== Envío de Entradas (PDF) (R21)

  - Enviar correo electrónico al comprador con detalles del evento, enlace a la página de detalles y entradas en PDF.

===== Envío de Recordatorio Previo al Evento (R22)

  - Enviar correo electrónico recordatorio un día antes del evento con enlace para descargar las entradas compradas.

===== Envío de Petición de Opinión Posterior al Evento (R23)

  - Enviar correo electrónico de valoración al comprador un día después del evento con enlace personalizado a la página de "Deja tu opinión".

===== Página "Deja tu Opinión" (R24)

  - Solicitar nombre, opinión con iconos de caritas, puntuación con iconos de estrellas, título del comentario y comentario en sí.

===== Mostrar Opiniones en la Página de Detalles del Evento (R25)
  - Mostrar opiniones y valoraciones de los compradores en la página de detalles del evento.

== Lineas futuras.
== Conclusiones

=== Desviaciones en la Planificación

Se revisarán las desviaciones en el plan inicial del proyecto y se proporcionarán explicaciones para las diferencias.

=== Aportaciones del Proyecto a los Conocimientos del Alumno

Se resaltarán las aportaciones significativas del proyecto al desarrollo de los conocimientos de los miembros del equipo.

== Glosario

Se proporcionará un listado de términos técnicos con sus definiciones.

== Webgrafía

Se citarán las fuentes web utilizadas en el desarrollo del proyecto.

== Otros Recursos de Consulta

Se incluirán otros recursos utilizados como libros, artículos, etc.

== Presentación del Proyecto

Se preparará una presentación breve del proyecto para compartir con la audiencia.
